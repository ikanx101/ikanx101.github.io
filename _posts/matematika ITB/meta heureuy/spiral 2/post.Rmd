---
title: "METAHEURISTIC: SPIRAL OPTIMIZATION ALGORITHM part 2"
output: 
  github_document:
    pandoc_args: --webtex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

setwd("~/ikanx101 BLOG/_posts/matematika ITB/meta heureuy/spiral 2")

rm(list=ls())
library(dplyr)
library(ggplot2)
```

## Program _Spiral Optimization Algorithm_

Berbekal program yang telah dituliskan di bagian sebelumnya, kita akan sempurnakan program untuk melakukan _spiral optimization_ sebagai berikut:

```{r}
soa_mrf = function(N,	  # banyak titik
		   x1_d,  # batas bawah x1
		   x1_u,  # batas atas x1
		   x2_d,  # batas bawah x2
		   x2_u,  # batas atas x2
		   rot,	  # berapa banyak rotasi
		   k_max, # iterasi maks
		   r){	  # berapa rate konstraksi
		   
# N pasang titik random di selang [a,b] di R2
x1 = runif(N,x1_d,x1_u)
x2 = runif(N,x2_d,x2_u)

# hitung theta
theta = 2*pi / rot

# definisi matriks rotasi
A = matrix(c(cos(theta),-sin(theta),
             sin(theta),cos(theta)),
           ncol = 2,byrow = T)

# bikin data frame
temp = data.frame(x1,x2) %>% mutate(f = f(x1,x2))

# proses iterasi
for(i in 1:k_max){
  # mencari titik x* dengan min(f)
  f_min = 
	temp %>% 
	filter(f == min(f))
  pusat = c(f_min$x1,f_min$x2)

  for(j in 1:N){
	# kita akan ambil titiknya satu persatu
	x0 = c(temp$x1[j],temp$x2[j])
	
	# proses rotasi dan konstraksi terhadap pusat x*
	xk = A %*% (x0-pusat) # diputar dengan x_bin sebagai pusat
        xk = pusat + (r * xk)
	
	# proses mengembalikan nilai ke temp
	temp$x1[j] = xk[1]
	temp$x2[j] = xk[2]
	}
    
    # hitung kembali nilai f(x1,x2)
    temp = temp %>% mutate(f = f(x1,x2))
    }

# proses output hasil
output = temp %>% filter(f == min(f))
return(output)
}

```


### Contoh Penggunaan Program

Kita akan coba performa program tersebut untuk menyelesaikan fungsi berikut:

$$f(x_1,x_2) = \frac{x_1^4 - 16 x_1^2 + 5 x_1}{2} + \frac{x_2^4 - 16 x_2^2 + 5 x_2}{2}$$

$$-4 \leq x_1,x_2 \leq 4$$

Dengan $r = 0.8, N = 50, rot = 20, k_{max} = 60$.

```{r}
# definisi
N = 50
a = -4 # x1 dan x2 punya batas bawah yang sama
b = 4  # x1 dan x2 punya batas atas yang sama
k_max = 70
r = .75
rot = 30
f = function(x1,x2){
	((x1^4 - 16 * x1^2 + 5 * x1)/2) + ((x2^4 - 16 * x2^2 + 5* x2)/2)
	}

# solving
soa_mrf(N,a,b,a,b,rot,k_max,r)
```

__Catatan__

Pada algoritma ini, penentuan $\theta, r, x$ menjadi penentu hasil perhitungan.

<br>

### Mengubah Optimisasi Menjadi Pencarian Akar

_Spiral optimization algorithm_ adalah suatu metode untuk mencari solusi minimum global. Jika kita hendak memakainya untuk mencari suatu akar persamaan (atau sistem persamaan), kita bisa melakukan modifikasi pada fungsi-fungsi yang terlibat (membuat fungsi _merit_).

Misalkan suatu sistem persamaan non linear:

$$g_1 (x_1,x_2,..,x_n) = 0$$

$$g_2 (x_1,x_2,..,x_n) = 0$$

$$g_n (x_1,x_2,..,x_n) = 0$$

dengan $(x_1,x_2,..,x_n)^T \in D$

$$D = a_1,b_1 \times a_2,b_2 \times .. \times a_n,b_n \subset \mathbb{R}^n$$


#### Pencarian Akar

Sistem di atas memiliki solusi $x = (x_1,x_2,..,x_n)^T$ jika $F(x)$ yang kita definisikan sebagai:

$$F(x) = \frac{1}{1+ \sum_{i=1}^n |g_i(x)|}$$


memiliki nilai maksimum sama dengan 1. __Akibatnya algoritma yang sebelumnya adalah mencari $\min{F(x)}$ diubah menjadi__ $\max{F(x)}$. Kenapa demikian?

> Karena jika $F(x) = 1$ artinya $\sum_{i=1}^n |g_i(x)| = 0$ yang merupakan akar dari $g_i,i = 1,2,..,n$.

__Kelak__ $F(x)$ __akan digunakan untuk menjawab soal-soal yang ada dalam tulisan ini.__

```{r,include = FALSE}
soa_mrf_2 = function(N,	  # banyak titik
		     x1_d,  # batas bawah x1
		     x1_u,  # batas atas x1
		     x2_d,  # batas bawah x2
		     x2_u,  # batas atas x2
		     rot,   # berapa banyak rotasi
		     k_max, # iterasi maks
		     r){    # berapa rate konstraksi
		   
# N pasang titik random di selang [a,b] di R2
x1 = runif(N,x1_d,x1_u)
x2 = runif(N,x2_d,x2_u)

# hitung theta
theta = 2*pi / rot

# definisi matriks rotasi
A = matrix(c(cos(theta),-sin(theta),
             sin(theta),cos(theta)),
           ncol = 2,byrow = T)

# bikin data frame
temp = data.frame(x1,x2) %>% mutate(f = f(x1,x2))

# proses iterasi
for(i in 1:k_max){
  # mencari titik x* dengan max(f)
  f_min = 
	temp %>% 
	filter(f == max(f))
  pusat = c(f_min$x1,f_min$x2)

  for(j in 1:N){
	# kita akan ambil titiknya satu persatu
	x0 = c(temp$x1[j],temp$x2[j])
	
	# proses rotasi dan konstraksi terhadap pusat x*
	xk = A %*% (x0-pusat) # diputar dengan x_bin sebagai pusat
        xk = pusat + (r * xk)
	
	# proses mengembalikan nilai ke temp
	temp$x1[j] = xk[1]
	temp$x2[j] = xk[2]
	}
    
    # hitung kembali nilai f(x1,x2)
    temp = temp %>% mutate(f = f(x1,x2))
    }

# proses output hasil
output = temp %>% filter(f == min(f))
return(output)
}

```


<br>

```{r,include=FALSE}
# fungsi plot
# untuk contour plot
ikanx = function(f,a,b){
  x = seq(a,b,by = .25)

  temp_plot =
    expand.grid(x,x) %>%
    rename(x = Var1,
           y = Var2) %>%
    mutate(z = f(x,y))

  temp_plot %>%
     ggplot(aes(x = x,y = y,z = z)) +
     geom_contour() +
     theme_minimal() +
     labs(x = "x1",y = "x2",
	  caption = "Digambar dengan R\n20921004@mahasiswa.itb.ac.id")
}

# untuk sistem persamaan
ikanx_2 = function(f,a,b){
  x = seq(a,b,by = .025)

  temp_plot =
    expand.grid(x,x) %>%
    rename(x = Var1,
           y = Var2) %>%
    mutate(z = f(x,y)) %>%
    filter(round(z,1) == 0)

  return(temp_plot)
}


```

<br>

# CONTOH 1

Tentukanlah akar-akar sistem persamaan berikut dengan __SOA__. Buatlah terlebih dahulu _contour plot_-nya:

$$f_1 (x_1,x_2) = \cos{(2 x_1)} - \cos{(2 x_2)} - 0.4 = 0$$

$$f_2 (x_1,x_2) = 2 (x_2 - x_1) + \sin{ (x_2) } - \sin{(x_1)} - 1.2 = 0$$

dengan $-10 \leq x_1,x_2 \leq 10$

## Grafik Sistem Persamaan

Kita akan mencari akar-akar sistem persamaan saat $f_1 = 0$ dan $f_2=0$ dengan bantuan grafik sebagai berikut:

```{r out.width = "75%",echo=FALSE,fig.retina=5,fig.cap = "Plot Soal 1: f1 dan f2"}
f1 = function(x1,x2){cos(2* x1) - cos(2*x2) - 0.4}
f2 = function(x1,x2){2*(x2 - x1) + sin(x2) - sin(x1) - 1.2}

df1 = ikanx_2(f1,-10,10)
df2 = ikanx_2(f2,-10,10)

ggplot() +
  geom_point(data = df1, aes(x,y),color = "steelblue",size = .25) +
  geom_point(data = df2, aes(x,y),color = "darkgreen",size = .25) +
  theme_minimal() +
  labs(x = "x1",y = "x2",
       title = "Plot f1 dan f2",
       caption = "Digambar dengan R\nikanx101.com")
```

Terlihat bahwa ada beberapa titik solusi (persinggungan antara $f_1(x_1,x_2)$ dengan $f_2(x_1,x_2)$.


<br>

## Mencari Akar Sistem Persamaan

Untuk mencari akarnya kita perlu membentuk $F(x)$ sebagaimana yang telah dijelaskan pada bagian sebelumnya.

```{r}
# fungsi f1 dan f2 dari soal
f1 = function(x1,x2){cos(2* x1) - cos(2*x2) - 0.4}
f2 = function(x1,x2){2*(x2 - x1) + sin(x2) - sin(x1) - 1.2}

# membuat F(x)
# saya notasikan sebagai f kecil
f = function(x1,x2){
  sum = abs(f1(x1,x2)) + abs(f2(x1,x2))
  bawah = 1 + sum
  hasil = 1/bawah
  return(hasil)
}
```

Oleh karena solusi dari grafik ada banyak, maka kita akan _run_ program yang telah dibuat sebelumnya berulang kali:

```{r}
# solving
N = 50
a = -10  # x1 dan x2 punya batas yang sama
b = 10   # x1 dan x2 punya batas yang sama
rot = 20
k_max = 60
r = .65
# run I
soa_mrf_2(N,a,b,a,b,rot,k_max,r)
# run II
soa_mrf_2(N,a,b,a,b,rot,k_max,r)
# run III
soa_mrf_2(N,a,b,a,b,rot,k_max,r)
```

<br>

Berikutnya saya coba _run_ sebanyak __100 kali__, berikut adalah rekap semua akar yang saya dapatkan:

```{r,echo=FALSE,warning=FALSE,message=FALSE}
ceisya = data.frame()

for(i in 1:100){
  ahnaf = soa_mrf_2(N,a,b,a,b,rot,k_max,r)
  ceisya = rbind(ahnaf,ceisya)
}

ceisya %>% 
  mutate(x1 = round(x1,1),
         x2 = round(x2,1),
	 f = round(f,1)) %>% 
  distinct() %>%
  arrange(x1,x2)
```

`BERSAMBUNG`